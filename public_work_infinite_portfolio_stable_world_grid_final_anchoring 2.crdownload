// Public Work Infinite Portfolio — Stable World Grid (Final Anchoring, Wheel Fix)
// -------------------------------------------------------------------
// Fixed: Trackpad/mouse‑wheel scroll was reversed. Now subtracting deltas
// so two‑finger right/down moves content right/down, same as drag.

import React, { useEffect, useMemo, useRef, useState } from 'react';

// ----------------------- Config & Geometry -----------------------
const TILE_W = 280;
const TILE_H = 380;
const TILE_G = 22;
const COLW = TILE_W + TILE_G;
const ROWH = TILE_H + TILE_G;

const VISIBLE_COLS = 8;
const VISIBLE_ROWS = 6;

const TAGS = ['product', 'research', 'prototype', 'case'];

// ----------------------- Demo Data ----------------------
const projects = Array.from({ length: 30 }).map((_, i) => ({
  id: i + 1,
  title: `Project ${i + 1}`,
  subtitle: i % 3 === 0 ? 'Industrial Design' : i % 3 === 1 ? 'UX/UI' : 'Visual Comms',
  img: `https://picsum.photos/seed/pw${i + 1}/800/1100`,
  year: 2024 - (i % 4),
  tags: TAGS.slice(0, (i % 4) + 1),
  link: '#',
}));

// ----------------------- Utils ---------------------------
const mod = (v: number, n: number) => ((v % n) + n) % n;

function hashToIndex(row: number, col: number, len: number) {
  const A = 11400714819323198485n;
  let x = BigInt(row) * 0x9e3779b97f4a7c15n ^ BigInt(col) * 0xc2b2ae3d27d4eb4fn;
  x = (x * A) & 0xffffffffffffffffn;
  const asNum = Number(x & 0x7fffffffn);
  return len ? asNum % len : 0;
}

function colorFor(id: number): string {
  const hue = (id * 47) % 360;
  return `hsl(${hue} 65% 60%)`;
}

// ----------------------- Inertia Engine -------------------------
function useDragInertia() {
  const [offset, setOffset] = useState({ x: 0, y: 0 });
  const vel = useRef({ x: 0, y: 0 });
  const state = useRef({ dragging: false, x: 0, y: 0, t: 0 });
  const raf = useRef(0);

  const stopRaf = () => { if (raf.current) cancelAnimationFrame(raf.current); raf.current = 0; };

  const onPointerDown = (e: React.PointerEvent) => {
    (e.target as HTMLElement).setPointerCapture?.(e.pointerId);
    stopRaf();
    state.current.dragging = true;
    state.current.x = e.clientX;
    state.current.y = e.clientY;
    state.current.t = performance.now();
  };

  const onPointerMove = (e: React.PointerEvent) => {
    if (!state.current.dragging) return;
    const now = performance.now();
    const dt = Math.max(1, now - state.current.t);
    const dx = e.clientX - state.current.x;
    const dy = e.clientY - state.current.y;
    vel.current.x = (dx / dt) * 16;
    vel.current.y = (dy / dt) * 16;
    state.current.x = e.clientX;
    state.current.y = e.clientY;
    state.current.t = now;
    setOffset((o) => ({ x: o.x + dx, y: o.y + dy }));
  };

  const onPointerUp = (e: React.PointerEvent) => {
    (e.target as HTMLElement).releasePointerCapture?.(e.pointerId);
    state.current.dragging = false;
    const FRICTION = 0.94;
    const MIN_SPEED = 0.2;
    const step = () => {
      vel.current.x *= FRICTION;
      vel.current.y *= FRICTION;
      setOffset((o) => ({ x: o.x + vel.current.x, y: o.y + vel.current.y }));
      if (Math.hypot(vel.current.x, vel.current.y) > MIN_SPEED) raf.current = requestAnimationFrame(step);
      else stopRaf();
    };
    stopRaf();
    raf.current = requestAnimationFrame(step);
  };

  useEffect(() => () => stopRaf(), []);

  return { offset, setOffset, onPointerDown, onPointerMove, onPointerUp };
}

// ----------------------- Component ------------------------------
export default function PublicWorkWorldStable() {
  const { offset, setOffset, onPointerDown, onPointerMove, onPointerUp } = useDragInertia();

  const [openId, setOpenId] = useState<number | null>(null);
  const [showHelp, setShowHelp] = useState(false);
  const [query, setQuery] = useState('');
  const [activeTag, setActiveTag] = useState<string | null>(null);

  useEffect(() => {
    const onKey = (e: KeyboardEvent) => {
      if (e.key === '?') setShowHelp((s) => !s);
      if (e.key === 'Escape') setOpenId(null);
      const STEP = e.shiftKey ? 140 : 60;
      if (['ArrowLeft', 'ArrowRight', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
        e.preventDefault();
        const dx = e.key === 'ArrowLeft' ? -STEP : e.key === 'ArrowRight' ? STEP : 0;
        const dy = e.key === 'ArrowUp' ? -STEP : e.key === 'ArrowDown' ? STEP : 0;
        setOffset((o) => ({ x: o.x + dx, y: o.y + dy }));
      }
    };
    window.addEventListener('keydown', onKey as any);
    return () => window.removeEventListener('keydown', onKey as any);
  }, [setOffset]);

  // Trackpad / mouse‑wheel panning — subtract deltas to correct direction
  const onWheel = (e: React.WheelEvent) => {
    e.preventDefault();
    setOffset((o) => ({ x: o.x - e.deltaX, y: o.y - e.deltaY }));
  };

  const filtered = useMemo(() => {
    const q = query.trim().toLowerCase();
    return projects.filter((p) =>
      (!activeTag || p.tags.includes(activeTag)) &&
      (!q || p.title.toLowerCase().includes(q) || p.subtitle.toLowerCase().includes(q))
    );
  }, [query, activeTag]);

  const camX = -offset.x;
  const camY = -offset.y;

  const vw = typeof window !== 'undefined' ? window.innerWidth : 1200;
  const vh = typeof window !== 'undefined' ? window.innerHeight : 800;
  const marginCols = 2;
  const marginRows = 2;

  const baseLeft = (vw - VISIBLE_COLS * COLW) / 2;
  const baseTop = (vh - VISIBLE_ROWS * ROWH) / 2;

  const firstCol = Math.floor((camX - baseLeft) / COLW) - marginCols;
  const firstRow = Math.floor((camY - baseTop) / ROWH) - marginRows;
  const colsToDraw = VISIBLE_COLS + marginCols * 2;
  const rowsToDraw = VISIBLE_ROWS + marginRows * 2;

  const cells = useMemo(() => {
    const arr: { row: number; col: number; projId: number }[] = [];
    const len = Math.max(1, filtered.length);
    for (let r = 0; r < rowsToDraw; r++) {
      for (let c = 0; c < colsToDraw; c++) {
        const row = firstRow + r;
        const col = firstCol + c;
        const idx = hashToIndex(row, col, len);
        arr.push({ row, col, projId: filtered[idx].id });
      }
    }
    return arr;
  }, [filtered, firstRow, firstCol, rowsToDraw, colsToDraw]);

  return (
    <div
      className="relative h-dvh w-dvw overflow-hidden select-none"
      style={{ background: '#fafafa', color: '#111', overscrollBehavior: 'none' }}
    >
      <div
        onWheel={onWheel}
        onPointerDown={onPointerDown}
        onPointerMove={onPointerMove}
        onPointerUp={onPointerUp}
        style={{ position: 'absolute', inset: 0, cursor: 'grab' }}
      >
        {cells.map(({ row, col, projId }) => (
          <Tile
            key={`${row}:${col}`}
            left={baseLeft + col * COLW + offset.x}
            top={baseTop + row * ROWH + offset.y}
            projId={projId}
            onOpen={(id) => setOpenId(id)}
          />
        ))}
      </div>
    </div>
  );
}

function Tile({ left, top, projId, onOpen }: { left: number; top: number; projId: number; onOpen: (id: number) => void }) {
  return (
    <div className="group" style={{ position: 'absolute', left, top, width: TILE_W, height: TILE_H }}>
      <div style={{ position: 'relative', width: '100%', height: '100%', overflow: 'hidden', borderRadius: 16, border: '1px solid #e5e5e5', background: colorFor(projId), display: 'grid', placeItems: 'center', fontSize: 28, fontWeight: 800, color: 'rgba(0,0,0,0.6)' }}>
        {projId}
        <button onMouseDown={() => onOpen(projId)} style={{ position: 'absolute', right: 8, top: 8 }}>Open</button>
      </div>
    </div>
  );
}
